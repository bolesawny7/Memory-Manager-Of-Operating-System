/*
 * dynamic_allocator.c
 *
 *  Created on: Sep 21, 2023
 *      Author: HP
 */
#include <inc/assert.h>
#include <inc/string.h>
#include "../inc/dynamic_allocator.h"
#define true 1
#define false 0

//==================================================================================//
//============================== GIVEN FUNCTIONS ===================================//
//==================================================================================//

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void *va) {
	uint32 *curBlkMetaData = ((uint32 *) va - 1);
	return (*curBlkMetaData) & ~(0x1);
}

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void *va) {
	uint32 *curBlkMetaData = ((uint32 *) va - 1);
//	cprintf("curBlkMetaData address: %p, value: %x\n", curBlkMetaData, *curBlkMetaData);
	return (~(*curBlkMetaData) & 0x1);
}

//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY) {
	void *va = NULL;
	switch (ALLOC_STRATEGY) {
	case DA_FF:
		va = alloc_block_FF(size);
		break;
	case DA_NF:
		va = alloc_block_NF(size);
		break;
	case DA_BF:
		va = alloc_block_BF(size);
		break;
	case DA_WF:
		va = alloc_block_WF(size);
		break;
	default:
		cprintf("Invalid allocation strategy\n");
		break;
	}
	return va;
}

//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list) {
	cprintf("=========================================\n");
	struct BlockElement *blk;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
	{
		cprintf("(size: %d, isFree: %d at address %p)\n", get_block_size(blk),
				is_free_block(blk), blk);
	}
	cprintf("=========================================\n");
}
//
////********************************************************************************//
////********************************************************************************//

//==================================================================================//
//============================ REQUIRED FUNCTIONS ==================================//
//==================================================================================//

bool is_initialized = 0;
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
void initialize_dynamic_allocator(uint32 daStart,
		uint32 initSizeOfAllocatedSpace) {
	//==================================================================================
	// DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0)
			initSizeOfAllocatedSpace++; // ensure it's multiple of 2
		if (initSizeOfAllocatedSpace == 0)
			return;
		is_initialized = 1;
	}
	//==================================================================================
	//==================================================================================

	// TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	// COMMENT THE FOLLOWING LINE BEFORE START CODING
	// panic("initialize_dynamic_allocator is not implemented yet");
	// Your Code is Here...
	LIST_INIT(&freeBlocksList);

	uint32 *BEG_Block = (uint32 *) daStart;
	uint32 *END_Block = (uint32 *) (daStart + initSizeOfAllocatedSpace
			- sizeof(uint32));
	uint32 *Header = (uint32 *) (daStart + sizeof(uint32));
	uint32 *Footer = (uint32 *) (daStart + initSizeOfAllocatedSpace
			- 2 * sizeof(uint32));

	*Header = (initSizeOfAllocatedSpace - 2 * sizeof(uint32));
	*Footer = (initSizeOfAllocatedSpace - 2 * sizeof(uint32));
	struct BlockElement *firstFreeBlock = (struct BlockElement *) (daStart
			+ 2 * sizeof(uint32));

	*BEG_Block = 0 | (0x1);
	*END_Block = 0 | (0x1);
	freeBlocksList.lh_first = firstFreeBlock;
	freeBlocksList.size = 1;
	LIST_HEAD(freeBlocksList, firstFreeBlock);

	// set Block Test

	//    void * va = (void*)0xF6543210;;
	//    set_block_data(va,9*sizeof(int), 1);
	//    uint32 res =  get_block_size(va);
	//    panic("BLOCK Size: %d\n\n",res);
	//    int8 res = is_free_block(va);
	//    panic("IS FREE BLOCK : %d\n\n",res);
}
//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void *va, uint32 totalSize, bool isAllocated) {
	// TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
	// COMMENT THE FOLLOWING LINE BEFORE START CODING
	//	panic("set_block_data is not implemented yet");
	//	Your Code is Here...

	uint32 header_footer_data;
	// lw allocated el flag = 1 lw la =0
	if (isAllocated) {
		header_footer_data = totalSize | 1;
	} else {
		header_footer_data = totalSize | 0;
	}
	// el header abl el address b 4 bytes
	*(uint32 *) (va - sizeof(uint32)) = header_footer_data;

	// el footer 3nd el address + el size - size of el footer wl header
	*(uint32 *) (va + totalSize - 2 * (sizeof(uint32))) = header_footer_data;
}

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size) {
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0)
			size++;	//ensure that the size is even (to use LSB as allocation flag)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
			size = DYN_ALLOC_MIN_BLOCK_SIZE;
		if (!is_initialized) {
			uint32 required_size = size + 2 * sizeof(int) /*header & footer*/
			+ 2 * sizeof(int) /*da begin & end*/;
			uint32 da_start = (uint32) sbrk(
			ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
			uint32 da_break = (uint32) sbrk(0);
			initialize_dynamic_allocator(da_start, da_break - da_start);
		}
	}
	//==================================================================================
	//==================================================================================

	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...
	if (size == 0)
		return NULL;
	uint32* current;
	uint32 required_size = size + 2 * sizeof(int);
	struct BlockElement *first;
	struct BlockElement *latest;
	bool noBlocks = 1;
	LIST_FOREACH(first , &freeBlocksList)
	{
		int x = get_block_size(first);

    	cprintf("x => %d", x );
    	cprintf("requiredSize => %d", required_size );


		if (required_size > x) {
			continue;
		} else if ((required_size + (DYN_ALLOC_MIN_BLOCK_SIZE * 2)) <= x) {
	    	cprintf("im heere => \n" );

			current = (uint32*) ((char*) first);
			latest = (struct BlockElement*) ((char*) first + required_size);
			set_block_data((char*) first + required_size, x - required_size,
			false);
			if(freeBlocksList.size == 1){
		    	cprintf("im heere 2=> \n" );

				LIST_REMOVE(&freeBlocksList, first);
		    	cprintf("im heere first: %u=> \n", first );

		    	cprintf("im heere latest: %u=> \n", latest );
		    	cprintf("im heere latest: %u=> \n", current );

				freeBlocksList.lh_first = latest;

				LIST_INSERT_TAIL(&freeBlocksList, latest);
		        print_blocks_list(freeBlocksList);


			}else{
				LIST_INSERT_AFTER(&freeBlocksList, first, latest);
				LIST_REMOVE(&freeBlocksList, first);
			}


//			if (freeBlocksList.size == 1)

			noBlocks = 0;

			set_block_data((void*) first, required_size, true);

	    	cprintf("The End \n" );


			break;
		} else {
			current = (uint32*) ((char*) first);
			latest = (struct BlockElement*) ((char*) first);


			noBlocks = 0;

			set_block_data((void*) (first), x, true);

			LIST_REMOVE(&freeBlocksList, first);

			break;

		}
	}
    if (noBlocks) {
        bool isLastFree = false;
        int lastFreeBlockSize = 0;
        struct BlockElement *lastFreeBlock = NULL;

        // Check if the last block in the free list is free
        if (LIST_SIZE(&freeBlocksList) > 0) {
            lastFreeBlock = LIST_LAST(&freeBlocksList);

            // Move to the last block in the list
            while (LIST_NEXT(lastFreeBlock) != NULL) {
                lastFreeBlock = LIST_NEXT(lastFreeBlock);
            }

            // If the last block is free, use it for merging
            if (is_free_block(lastFreeBlock)) {
                isLastFree = true;
                lastFreeBlockSize = get_block_size(lastFreeBlock);
            }
        }

        // Calculate the number of pages required
        int totalSize = required_size;
        if (isLastFree) {
            totalSize -= lastFreeBlockSize;
        }
//        int numOfPages = ROUNDUP(totalSize ,PAGE_SIZE);

        int numOfPages = (totalSize + PAGE_SIZE - 1) / PAGE_SIZE;

        // Request additional memory from the kernel
        void *sbrkV = sbrk(numOfPages);
        if (sbrkV == (void *)-1) {
            return NULL;
        }


        print_blocks_list(freeBlocksList);

    	cprintf("requiredSize => %d\n", required_size );
    	cprintf("numOfPages => %d\n", numOfPages * PAGE_SIZE );


        // If the last block was free, merge it with the new allocation
        if (isLastFree) {
//            LIST_REMOVE(&freeBlocksList, lastFreeBlock);
            set_block_data(lastFreeBlock, lastFreeBlockSize + numOfPages * PAGE_SIZE, false);

//            LIST_INSERT_TAIL(&freeBlocksList, lastFreeBlock );
            current = (uint32 *)lastFreeBlock ;

            struct BlockElement *latestBlock = (struct BlockElement*) ((char*) lastFreeBlock + required_size);
			set_block_data((char*) lastFreeBlock + required_size , lastFreeBlockSize + numOfPages * PAGE_SIZE - required_size,
			false);
			if(freeBlocksList.size == 1){
		    	cprintf("im heere 2=> \n" );

				LIST_REMOVE(&freeBlocksList, lastFreeBlock);
		    	cprintf("im heere latest: %u=> \n", latestBlock );
		    	cprintf("im heere latest: %u=> \n", current );

				freeBlocksList.lh_first = latest;

				LIST_INSERT_TAIL(&freeBlocksList, latestBlock);
		        print_blocks_list(freeBlocksList);


			}else{
				LIST_INSERT_AFTER(&freeBlocksList, first, latestBlock);
				LIST_REMOVE(&freeBlocksList, first);
			}

			noBlocks = 0;

			set_block_data((void*) lastFreeBlock, required_size, true);

        	print_blocks_list(freeBlocksList);

//            set_block_data((void *)current, required_size , true);
        } else {
            current = (uint32 *)sbrkV;
            set_block_data((void *)current, required_size, true);
        }

        // Set the allocated block data
        if(noBlocks == 1){
            // Create a new free block for remaining space
            uint32 remaining_size = (numOfPages * PAGE_SIZE) - required_size;
            if (remaining_size >= DYN_ALLOC_MIN_BLOCK_SIZE) {
                struct BlockElement *remainingBlock = (struct BlockElement *)((char *)current + required_size);
                set_block_data((void *)remainingBlock, remaining_size, false);
                free_block((void *)remainingBlock);
            }
        }
    }

    return current;
}
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size) {
    if (size == 0) {
        return NULL;
    }

    uint32 size_with_metadata = size + 2 * sizeof(uint32);
    struct BlockElement* blk;
    struct BlockElement* bestFitBlock = NULL;

    // Find the smallest free block that can fit the requested size
    LIST_FOREACH(blk, &freeBlocksList) {
        uint32 current_blk_size_from_header = get_block_size((void *) blk);
        if (current_blk_size_from_header >= size_with_metadata &&
           (bestFitBlock == NULL || current_blk_size_from_header < get_block_size(bestFitBlock))) {
            bestFitBlock = blk;
        }
    }

    if (bestFitBlock != NULL) {
        uint32 best_blk_size = get_block_size(bestFitBlock);
        uint32 remaining = best_blk_size - size_with_metadata;

        if (remaining < 2 * DYN_ALLOC_MIN_BLOCK_SIZE) {
            set_block_data((void*) bestFitBlock, best_blk_size, 1);
            LIST_REMOVE(&freeBlocksList, bestFitBlock);
        } else {
            set_block_data((void*) bestFitBlock, size_with_metadata, 1);
            struct BlockElement* remaining_blk = (struct BlockElement *) ((char *) bestFitBlock + size_with_metadata);
            set_block_data((void *) remaining_blk, remaining, 0);
            LIST_INSERT_AFTER(&freeBlocksList, bestFitBlock, remaining_blk);
            LIST_REMOVE(&freeBlocksList, bestFitBlock);  // Remove before splitting
        }
        return (void *) bestFitBlock;
    }

    return NULL;  // Explicitly return NULL if no suitable block is found
}

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void* va) {
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//panic("free_block is not implemented yet");
//Your Code is Here...
	if (va == NULL)
		return;

	struct BlockElement* initialBlock = (struct BlockElement*) va;
	uint32* prevFooter = (uint32 *) ((char *) initialBlock - 2 * sizeof(uint32));
	;
	int prevSize = *prevFooter & ~0x1;
	initialBlock->prev_next_info.le_prev =
			(struct BlockElement*) ((char *) initialBlock - prevSize);
	initialBlock->prev_next_info.le_next =
			(struct BlockElement*) ((char *) initialBlock
					+ get_block_size(initialBlock));
	struct BlockElement* currentBlock;
	struct BlockElement* currentFreeBlock;
	uint32* firstFlag;
	uint32* lastFlag;

	if (is_free_block(va) == 0) {

		int x = get_block_size(initialBlock);
		set_block_data(va, x, false);
		if (freeBlocksList.size == 0) {
			LIST_INSERT_HEAD(&freeBlocksList, initialBlock);
			return;
		}
		firstFlag = (uint32*) (va - sizeof(uint32) - sizeof(uint32));

		lastFlag = (uint32*) (va + x - sizeof(uint32));


		if (is_free_block(initialBlock->prev_next_info.le_prev) == 1
				&& *firstFlag != 1) {

			int y = get_block_size(initialBlock->prev_next_info.le_prev);
			//panic("%d\n", y);
			currentBlock = initialBlock->prev_next_info.le_prev;
			LIST_REMOVE(&freeBlocksList, currentBlock);
			set_block_data(currentBlock, x + y, false);

			if (is_free_block(initialBlock->prev_next_info.le_next) == 1
					&& *lastFlag != 1) {
				int z = get_block_size(initialBlock->prev_next_info.le_next);

				LIST_REMOVE(&freeBlocksList,
						initialBlock->prev_next_info.le_next);

				set_block_data(initialBlock->prev_next_info.le_prev, x + y + z,
				false);
				struct BlockElement* holdingBlock = NULL;
				LIST_FOREACH(currentFreeBlock,&freeBlocksList)
				{
					if (currentBlock > currentFreeBlock) {
						holdingBlock = currentFreeBlock;
					}
				}
				if (holdingBlock != NULL) {
					LIST_INSERT_AFTER(&freeBlocksList, holdingBlock,
							currentBlock);
				} else {
					LIST_INSERT_HEAD(&freeBlocksList, currentBlock);
				}
			} else {
				struct BlockElement* holdingBlock = NULL;
				LIST_FOREACH(currentFreeBlock,&freeBlocksList)
				{
					if (currentBlock > currentFreeBlock) {
						holdingBlock = currentFreeBlock;
					}
				}
				if (holdingBlock != NULL) {
					LIST_INSERT_AFTER(&freeBlocksList, holdingBlock,
							currentBlock);
				} else {
					LIST_INSERT_HEAD(&freeBlocksList, currentBlock);
				}
			}

		} else if (is_free_block(initialBlock->prev_next_info.le_next) == 1
				&& *lastFlag != 1) {


			struct BlockElement* afterBlock =
					initialBlock->prev_next_info.le_next;
			int z = get_block_size(initialBlock->prev_next_info.le_next);
			LIST_REMOVE(&freeBlocksList, initialBlock->prev_next_info.le_next);
			set_block_data(va, x + z, false);
			struct BlockElement* holdingBlock = NULL;
			LIST_FOREACH(currentFreeBlock,&freeBlocksList)
			{
				if (initialBlock > currentFreeBlock) {
					holdingBlock = currentFreeBlock;
				}
			}
			if (holdingBlock != NULL) {
				LIST_INSERT_AFTER(&freeBlocksList, holdingBlock, initialBlock);
			} else {
				LIST_INSERT_HEAD(&freeBlocksList, initialBlock);
			}

		} else {
			struct BlockElement* holdingBlock = NULL;
			LIST_FOREACH(currentFreeBlock,&freeBlocksList)
			{
				if (initialBlock > currentFreeBlock) {
					holdingBlock = currentFreeBlock;
				}
			}
			if (holdingBlock != NULL) {
				LIST_INSERT_AFTER(&freeBlocksList, holdingBlock, initialBlock);
			} else {
				LIST_INSERT_HEAD(&freeBlocksList, initialBlock);
			}
		}
	}


	if ((is_free_block(initialBlock->prev_next_info.le_next) != 1
			&& is_free_block(initialBlock->prev_next_info.le_prev) != 1)) {


		LIST_INSERT_TAIL(&freeBlocksList, initialBlock);
	}

}

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void *va, uint32 new_size) {
	cprintf("YASTA FE HAGA HENAAA REALLOCCC\n");
	// TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	// COMMENT THE FOLLOWING LINE BEFORE START CODING
//	 panic("realloc_block_FF is not implemented yet");
	// Your Code is Here...

	// law el va be Null keda fe 2 cases
	if (va == NULL) {
		//law fe size fa harouh a2olo allocate we a3mel block ba2a
		if (new_size) {
			return alloc_block_FF(new_size);
		}
		//law mafesh size yeb2a howa beyhazar we harag3lo null
		return NULL;
	}
	// law fe va we fe size hankamel 3ady law mafesh size han2olo ya3mel free block
	if (!new_size) {
		free_block(va);
		return NULL;
	}
	//hana3mel 2 blocks wahed el ana hashtaghal 3aleh we wahed el ba3do
	struct BlockElement* block = (struct BlockElement*) va;
	uint32 * next_blk = (uint32 *) ((char *) block + get_block_size(block));
	struct BlockElement* nextBlock = (struct BlockElement*) next_blk;
	uint32 currentBlockSize = get_block_size(va);
	uint32 newSizeWithMetaData = new_size + 2 * sizeof(int);

//	print_blocks_list(freeBlocksList);
//	cprintf("\nva: %d \n",va);
	// nhot fe e3tebarna en el block el m3ana deh momken teb2a akher haga fel freeBlockList
	bool isTail = (block == LIST_LAST(&freeBlocksList));

	//not tail, next free, can take the size needed
	if (is_free_block(nextBlock)
			&& (currentBlockSize + get_block_size(nextBlock) >= new_size)) {

		struct BlockElement* prevBlock = nextBlock->prev_next_info.le_prev;

		uint32 remainingSpace = currentBlockSize + get_block_size(nextBlock)
				- newSizeWithMetaData;
		set_block_data(va, newSizeWithMetaData, 1);

		if (remainingSpace >= 2 * DYN_ALLOC_MIN_BLOCK_SIZE) {
			struct BlockElement* newFreeBlock =
					(struct BlockElement*) ((char*) block + newSizeWithMetaData);

			set_block_data(newFreeBlock, remainingSpace, 0);
			LIST_INSERT_AFTER(&freeBlocksList, prevBlock, newFreeBlock);
			LIST_REMOVE(&freeBlocksList, nextBlock);
		} else {
			set_block_data(va, currentBlockSize + get_block_size(nextBlock), 1);
			LIST_REMOVE(&freeBlocksList, nextBlock);

		}
	}
	// decrease
	else if (currentBlockSize > newSizeWithMetaData) {
		uint32 remainingSize = currentBlockSize - newSizeWithMetaData;
		set_block_data(va, newSizeWithMetaData, 1);
		if (is_free_block(nextBlock)) {
			struct BlockElement* prevBlock = nextBlock->prev_next_info.le_prev;
			uint32 nextSize = get_block_size(nextBlock);
			set_block_data((char*)va + newSizeWithMetaData,
					remainingSize + nextSize, 0);
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*) prevBlock,(struct BlockElement*) va+newSizeWithMetaData);
			LIST_REMOVE(&freeBlocksList,nextBlock);
		} else {
			if (remainingSize >= 2 * DYN_ALLOC_MIN_BLOCK_SIZE) {
				uint32* nextFree = (uint32*) (va + newSizeWithMetaData);
				set_block_data(va+newSizeWithMetaData, remainingSize, 0);
				//TODO: To implement getting the previous free Block (7atenaha keda delwa2ty)
				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)nextFree);
//				free_block(nextFree);
			} else {
				set_block_data(va, currentBlockSize, 1);
			}
		}
	} else if (!is_free_block(nextBlock)
			&& (currentBlockSize + get_block_size(nextBlock) >= new_size)) {

		alloc_block_FF(newSizeWithMetaData);
		set_block_data(va, currentBlockSize, 0);
	}
	return va;

}

/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size) {
	panic("alloc_block_WF is not implemented yet");
	return NULL;
}

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size) {
	panic("alloc_block_NF is not implemented yet");
	return NULL;
}
